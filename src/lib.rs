//! As a library crate, `img_dup` provides tools for searching for images, hashing them in
//! parallel, and collating their hashes to find near or complete duplicates.
//!
//!

extern crate "rustc-serialize" as serialize;
extern crate img_hash;
extern crate time;

mod img;

use img_hash::HashType;

use image;
use image::{DynamicImage, GenericImage, ImageError};

use time::{Tm, now, precise_time_ns};

pub use img::{
    HashTime,
    Image, 
    LoadTime,
    UniqueImage
};

use std::borrow::ToOwned;
use std::fs::{self, DirEntry, PathExt};
use std::io;
use std::path::{AsPath, Path, PathBuf};
use std::thread::Thread;
use std::ascii::AsciiExt;
use std::boxed::BoxAny;
use std::io::IoResult;
use std::io::fs::PathExtensions;
use std::path::{Path, PathBuf};
use std::rt::unwind::try;
use std::sync::atomic::{AtomicUsize, Relaxed};

macro_rules! setter {
    ($field:ident: $field_ty:ty) => (
        /// Set this field on `self`, returning `self` for method chaining.
        pub fn $field(&mut self, $field: $field_ty) -> &mut $ty {
            self.$field = $field;
            self
        }
    )
}

pub static DEFAULT_EXTS: &[&str] = &["jpg", "png", "gif"];

/// A helper struct for searching for image files within a directory.
pub struct ImageSearch<'a> {
    /// The directory to search
    pub dir: &'a Path,
    /// If the search should be recursive (visit subdirectories)
    pub recursive: bool,
    /// The extensions to match.
    pub exts: Vec<&'a str>,
}

impl ImageSearch {
    /// Initiate a search builder with the base search directory.
    /// Starts with a copy of `DEFAULT_EXTS` for the list of file extensions,
    /// and `recursive` set to `false`.
    pub fn with_dir<P: AsPath>(dir: &P) -> ImageSearch<'a> {
        ImageSearch {
            dir: dir.as_path(),
            recurse: false,
            exts: DEFAULT_EXTS.to_owned(),
        }
    }

    setter! { recursive: bool }

    /// Add an extension to the list on `self`,
    /// returning `self` for method chaining
    pub fn ext(&mut self, ext: &str) -> &mut ImageSearch<'a> {
        self.exts.push(ext);
        self
    }

    /// Add all the extensions from `exts` to `self,
    /// returning `self` for method chaining
    pub fn exts(&mut self, exts: &[&str]) -> &mut ImageSearch<'a> {
        self.exts.push_all(exts.iter());
        self
    }

    /// Create an iterator that searches `self.dir` for images with extensions contained in `self.exts`,
    /// recursing into subdirectories if `self.recursive` is set to `true`.
    ///
    /// Any I/O errors during searching are safely filtered out.
    pub fn search(mut self) -> io::Result<Box<Iterator<Item=PathBuf>>> {
        /// Generic to permit code reuse
        fn do_filter<I: Iterator<Item=io::Result<DirEntry>>>(mut iter: I, exts: &[&str]) 
        -> Box<Iterator<Item=PathBuf>> {
            Box::new(
                iter.filter_map(Result::ok)
                    .map(DirEntry::path)
                    .filter(|path|
                        path.extension()
                            .map(|ext| exts.contains(ext))
                            .unwrap_or(false)
                    )
            )
        }

        // `match` instead of `if` for clarity
        let iter = match self.recursive {
            false => do_filter(try!(fs::read_dir(self.dir))),
            true => do_filter(try!(fs::walk_dir(self.dir))),
        };

        Ok(iter)
    }
}


pub const DEAFULT_HASH_SIZE: u32 = 16;
pub const DEFAULT_HASH_TYPE: HashType = HashType::Gradient;
pub const DEFAULT_THRESHOLD: f32 = 0.03;

/// A builder struct for bootstrapping an `img_dup` session.
pub struct SessionBuilder {

    /// The images to hash and compare.
    pub images: Vec<PathBuf>,

    /// The size of the hash to use.
    ///
    /// See the `HashType` documentation for the actual size 
    /// of a hash generated by each hash type.
    pub hash_size: u32,

    /// The type of the hash to use. See `HashType` for more information.
    pub hash_type: HashType,

    /// The percent (%) difference an image has to be from all others 
    /// to count as unique, expressed as a decimal.
    ///
    /// E.g. a 3% threshold should be set as `0.03`.
    pub threshold: f32,
}

impl SessionBuilder {
    /// Construct a `SessionBuilder` instance from the vector of paths,
    /// supplying values from the `DEFAULT_*` constants for the other fields.
    ///
    /// To search for images, use the `ImageSearch` struct.
    pub fn from_images<I: Iterator<Item=PathBuf>>(images: I) -> SessionBuilder {
        SessionBuilder {
            images: images.collect(),
            hash_size: DEAFULT_HASH_SIZE,
            hash_type: DEFAULT_HASH_TYPE,
            threshold: DEFAULT_THRESHOLD,
        }
    }

    setter! { hash_size: u32 }
    setter! { hash_type: HashType }
    setter! { threshold: f32 }

    /// Spawn an `img_dup` session, using `threads` if supplied,
    /// or the number of CPUs as reported by the OS otherwise (recommended).
    ///
    /// ### Note
    /// Regardless of the `threads` value, an additional thread will be used for result collation.
    ///
    /// If processing on a single background thread is preferred, use `spawn_background` instead.
    ///
    /// If you're going to be waiting for the result anyways, use `spawn_wait`, which spawns
    /// multiple processing threads but performs collation in the current thread.
    ///
    /// ### Panics
    /// If `threads` is `Some(value)` and `value == 0`.
    ///
    /// If `threads` is `None` and this method panics, then for some reason `std::os::num_cpus()`
    /// returned 0, which is probably bad.
    pub fn spawn_multithread(self, threads: Option<usize>) -> Session {
        let threads = threads.unwrap_or_else(std::os::num_cpus);
        assert!(threads > 0, "If `threads` is supplied, it must be nonzero!");

        
    }

    /// Spawn an `img_dup` session which performs all the processing and collation 
    /// on a single background thread.
    ///
    /// Not recommended unless you only want to spawn one thread but don't want to block
    /// in the current one.
    pub fn spawn_background(self) -> Session {

    }

    /// Perform the processing in the background but collating in the current thread, 
    /// and return the result when it is ready.
    ///
    /// See `spawn_multithread` for more information on the `threads` parameter.
    ///
    /// ### Panics
    /// If `threads` is `Some(value)` and `value == 0`.    
    ///
    /// If `threads` is `None` and this method panics, then for some reason `std::os::num_cpus()`
    /// returned 0, which is probably bad.
    pub fn spawn_wait(self, threads: Option<usize>) -> ImgResults {
    
    }

    /// Do all the processing and collation on the current thread and return the result directly.
    ///
    /// **Not** recommended unless avoiding extra threads altogether is somehow desirable.
    pub fn process_serial(self) -> ImgResults {
    
    } 
}

pub struct Session {
    background: JoinGuard<'static, 


}








;

#[derive(Clone)]
struct ParQueue {
    vec: Arc<Vec<PathBuf>>,
    curr: Arc<AtomicUsize>,
}

impl ParQueue {
    fn from_vec(vec: Vec<PathBuf>) -> ParQueue {
        ParQueue {
            vec: Arc::new(vec),
            curr: AtomicUsize::new(0),
        }
    }
}

impl Iterator for ParQueue {
    type Item = &Path;
    fn next(&mut self) -> Option<&Path> {
        let idx = self.curr.fetch_add(1, Relaxed);
        self.vec.get(idx)
    }
}

pub struct ImgResults {
    pub total: Total,
    pub start_time: Tm,
    pub end_time: Tm,
    pub uniques: Vec<UniqueImage>,
    pub errors: Vec<ProcessingError>,
}
   



pub struct HashSettings {
    pub hash_size: u32,
    pub hash_type: HashType,
    pub threshold: f32,
}



pub type ImageResult = Result<Image, ProcessingError>;

pub type TimedImageResult = Result<(Image, LoadTime, HashTime), ProcessingError>;

pub type Total = uint;

pub fn process(settings: &ProgramSettings, paths: Vec<Path>) -> Results {
    let start_time = now();

    let (total, uniques, errors) = process_multithread(settings, paths);

    Results {
        total: total,
        start_time: start_time,
        end_time: now(),
        uniques: uniques,
        errors: errors,
    }
}

fn process_multithread(settings: &ProgramSettings, paths: Vec<Path>)
    -> (Total, Vec<UniqueImage>, Vec<ProcessingError>) {
    let rx = spawn_threads(settings, paths);

    receive_images(rx, settings)
}

pub fn spawn_threads(settings: &ProgramSettings, paths: Vec<Path>)
    -> Receiver<TimedImageResult> {

    let work = ParQueue::from_vec(paths);

    let (tx, rx) = channel();

    let hash_settings = settings.hash_settings();

    for _ in range(0, settings.threads) {
        let task_tx = tx.clone();
        let mut task_work = work.clone();

        Thread::spawn(move || {
            for path in task_work {
                let img_result = load_and_hash_image(&hash_settings, path);

                if task_tx.send_opt(img_result).is_err() { break; }
            }
        });
    }

    rx
}

pub type ImgDupResult<T> = Result<T, ImgDupError>;

pub enum ImgDupError {
    LoadingErr(PathBuf, ImageError),
    LoadingPanic(PathBuf, String),
    HashingPanic(PathBuf, String),
}

fn load_and_hash_image(settings: &HashSettings, path: &Path) -> ImgDupResult<Image> {
    let (image, load_time) = try!(try_load_image(path));

    let (hash, hash_time) = match try_hash_image {
        Ok(ok) => ok,
        Err(cause) => ImgDupError::HashingPanic(path.to_path_buf(), cause),
    };

    let (width, height) = img.dimensions();    
    
    Ok(
        Image {
            path: path.to_path_buf(),
            hash: hash,
            dimensions: img.dimensions(),
            load_time: load_time,
            hash_time: hash_time,
        }
    )
}

fn try_fn<T, F: FnOnce() -> T>(f: F) -> Result<T, String> {
    let mut maybe: Option<T> = None;

    let err = unsafe { try(|| maybe = Some(f())) };

    match maybe {
        Some(val) => Ok(val),
        None => Err(err.unwrap_err().downcast().unwrap()),
    }
}


fn try_load_image(path: &Path) -> ImgDupResult<(DynamicImage, LoadTime)> {
    let start_load = precise_time_ns();
    let image = try_fn(|| image::open(&path));
    let load_time =  precise_time_ns() - start_load;

    match image {
        Ok(Ok(image)) => Ok((image, load_time)),
        Ok(Err(img_err)) => Err(ImgDupError::LoadingErr(path.to_path_buf(), img_err)),
        Err(cause) => Err(ImgDupError::LoadingPanic(path.to_path_buf(), cause)),
    }
}

fn try_hash_image(img: &DynamicImage, hash_settings: &HashSettings) -> Result<(ImageHash, HashTime), String> {
    let start_hash = precise_time_ns();
    let hash = try!(try_fn(|| ImageHash::hash(img, hash_size, hash_typ)));
    let hash_time = precise_time_ns() - start_hash;

    Ok((hash, hash_time))
}

fn receive_images(rx: Receiver<TimedImageResult>, settings: &ProgramSettings)
    -> (Total, Vec<UniqueImage>, Vec<ProcessingError>){
    let mut unique_images = Vec::new();
    let mut errors = Vec::new();
    let mut total = 0u;

    for img_result in rx.iter() {
        match img_result {
            Ok((image, _, _)) => {
                manage_images(&mut unique_images, image, settings);
                total += 1;
            },
            Err(img_err) => errors.push(img_err),
        }
    }

    (total, unique_images, errors)
}




