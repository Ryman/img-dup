//! As a library crate, `img_dup` provides tools for searching for images, hashing them in
//! parallel, and collating their hashes to find near or complete duplicates.
//!
//!
#![feature(collections, fs, io, old_path, os, path, std_misc)]

extern crate "rustc-serialize" as serialize;
extern crate img_hash;
extern crate image;
extern crate threadpool;

mod img;

use img::ImageManager;

pub use img::{
    Image,
    SimilarImage,
    UniqueImage
};

use img_hash::{HashType, ImageHash};

use image::{DynamicImage, GenericImage, ImageError};

use std::borrow::ToOwned;
use std::fs::{self, DirEntry};
use std::io;
use std::path::{AsPath, Path, PathBuf};
use std::rt::unwind::try;
use std::sync::Arc;
use std::sync::atomic::AtomicUsize;
use std::sync::atomic::Ordering::Relaxed;
use std::sync::mpsc::{channel, Receiver};
use std::time::Duration;
use std::thread;





pub const DEAFULT_HASH_SIZE: u32 = 16;
pub const DEFAULT_HASH_TYPE: HashType = HashType::Gradient;
pub const DEFAULT_THRESHOLD: f32 = 0.03;

/// A builder struct for bootstrapping an `img_dup` session.
pub struct SessionBuilder {

    /// The images to hash and compare.
    pub images: Vec<PathBuf>,

    /// The size of the hash to use.
    ///
    /// See the `HashType` documentation for the actual size
    /// of a hash generated by each hash type.
    pub hash_size: u32,

    /// The type of the hash to use. See `HashType` for more information.
    pub hash_type: HashType,

    /// The percent (%) difference an image has to be from all others
    /// to count as unique, expressed as a decimal.
    ///
    /// E.g. a 3% threshold should be set as `0.03`.
    pub threshold: f32,
}

macro_rules! setter {
    ($field:ident: $field_ty:ty) => (
        /// Set this field on `self`, returning `self` for method chaining.
        pub fn $field<'a>(&'a mut self, $field: $field_ty) -> &mut Self {
            self.$field = $field;
            self
        }
    )
}

impl SessionBuilder {
    /// Construct a `SessionBuilder` instance from the vector of paths,
    /// supplying values from the `DEFAULT_*` constants for the other fields.
    ///
    /// To search for images, use the `ImageSearch` struct.
    pub fn from_images(images: Vec<PathBuf>) -> SessionBuilder {
        SessionBuilder {
            images: images,
            hash_size: DEAFULT_HASH_SIZE,
            hash_type: DEFAULT_HASH_TYPE,
            threshold: DEFAULT_THRESHOLD,
        }
    }

    setter! { hash_size: u32 }
    setter! { hash_type: HashType }
    setter! { threshold: f32 }

    /// Spawn an `img_dup` session, using `threads` if supplied,
    /// or the number of CPUs as reported by the OS otherwise (recommended).
    ///
    /// ### Note
    /// Regardless of the `threads` value, an additional thread will be used for result collation.
    ///
    /// ### Panics
    /// If `threads` is `Some(value)` and `value == 0`.
    ///
    /// If `threads` is `None` and this method panics, then for some reason `std::os::num_cpus()`
    /// returned 0, which is probably bad.
    pub fn process_multithread(self, threads: Option<usize>) -> Session {
        let (settings, images) = self.recombine();
        Session::process_multithread(threads, settings, images)
    } 

    /// Do all the processing and collation on the current thread and return the result directly.
    ///
    /// **Not** recommended unless avoiding extra threads altogether is somehow desirable.
    pub fn process_local(self) -> ImgResults {
        let (settings, images) = self.recombine();

        let mut manager = ImageManager::new(settings.threshold);
        let mut errors = Vec::new(); 

        for image in images {
            match load_and_hash_image(settings, &image) {
                Ok(hashed_image) => manager.add_image(hashed_image),
                Err(img_err) => errors.push(img_err),
            }
        }

        ImgResults {
            uniques: manager.into_vec(),
            errors: errors,
        }
    }

    fn recombine(self) -> (HashSettings, Vec<PathBuf>) {
        let hash_settings = HashSettings {
            hash_size: self.hash_size,
            hash_type: self.hash_type,
            threshold: self.threshold,
        };

        (hash_settings, self.images)
    }
}

fn spawn_threads(threads: usize, settings: HashSettings, paths: Vec<PathBuf>) -> Receiver<ImageResult> {
    let queue = ParQueue::from_vec(paths);

    let (tx, rx) = channel();

    for _ in 0 .. threads {
        let task_tx = tx.clone();
        let task_queue = queue.clone();

        thread::spawn(move || {
            while let Some(path) = task_queue.next() {
                let img_result = load_and_hash_image(settings, path);

                if task_tx.send(img_result).is_err() { break; }
            }
        });
    }

    rx
}

pub struct Session {
    background: thread::JoinGuard<'static, ImgResults>,
    pub total: usize,
    pub status: Arc<RunningStatus>,
}

impl Session {
    fn process_multithread(threads: Option<usize>, settings: HashSettings, images: Vec<PathBuf>) -> Self {
        let threads = threads.unwrap_or_else(std::os::num_cpus);
        assert!(threads > 0, "If `threads` is supplied, it must be nonzero!");

        let total = images.len();
        let result_rx = spawn_threads(threads, settings, images);
        let status = RunningStatus::new();
        let move_status = status.clone();

        let background = thread::scoped(move || collect_images(result_rx, settings.threshold, move_status));

        Session {
            background: background,
            total: total,
            status: status,
        }
    }

    pub fn wait(self) -> ImgResults {
        self.background.join()
    }
}

#[derive(Clone)]
pub struct RunningStatus {
    done: AtomicUsize,
    errors: AtomicUsize,
}

impl RunningStatus {
    fn new() -> Self {
        RunningStatus {
            done: AtomicUsize::new(0),
            errors: AtomicUsize::new(0),
        }
    }

    pub fn done(&self) -> usize {
        self.done.load(Relaxed)
    }

    pub fn errors(&self) -> usize {
        self.errors.load(Relaxed)
    }

    pub fn total(&self) -> usize {
        self.done() + self.errors()
    }

    fn add_done(&self) {
        self.done.fetch_add(1, Relaxed);
    }

    fn add_error(&self) {
        self.errors.fetch_add(1, Relaxed);
    }
}

enum ImgStatus {
    Unhashed(PathBuf),
    Hashed(Image),
    Error(PathBuf, ImageError),
}

impl ImgStatus {
    fn hash(&mut self, status: &RunningStatus, settings: HashSettings) {
        let result = if let ImgStatus::Unhashed(path) = *self {
        
        }
    }
}

struct HashQueue {
    vec: Vec<ImgStatus>,
    curr: AtomicUsize,
}

impl HashQueue {
    fn from_vec(vec: Vec<PathBuf>) -> ParQueue {
        ParQueue {
            vec: vec.into_iter().map(|path| ImgStatus::Unhashed(path)).collect(),
            curr: AtomicUsize::new(0),
        }
    }

    fn next(&self) -> Option<&mut ImgStatus> {
        let idx = self.curr.fetch_add(1, Relaxed);
        self.vec.get(idx).map(|img| unsafe { &mut *(img as *const T as *mut T) })
    }
}

pub struct ImgResults {
    pub uniques: Vec<UniqueImage>,
    pub errors: Vec<ImgDupError>,
}

#[derive(Copy)]
struct HashSettings {
    hash_size: u32,
    hash_type: HashType,
    threshold: f32,
}



pub type ImgDupResult<T> = Result<T, ImgDupError>;

pub enum ImgDupError {
    LoadingErr(PathBuf, ImageError),
    LoadingPanic(PathBuf, String),
    HashingPanic(PathBuf, String),
}

fn load_and_hash_image(settings: HashSettings, path: &Path) -> ImgDupResult<Image> {
    let (image, load_time) = try!(try_load_image(path));

    let (hash, hash_time) = match try_hash_image(&image, settings) {
        Ok(ok) => ok,
        Err(cause) => return Err(ImgDupError::HashingPanic(path.to_path_buf(), cause)),
    };

    Ok(
        Image {
            path: path.to_path_buf(),
            hash: hash,
            dimensions: image.dimensions(),
            load_time: load_time,
            hash_time: hash_time,
        }
    )
}

fn duration_with_val<T, F: FnOnce() -> T>(f: F) -> (T, Duration) {
    let mut opt_val: Option<T> = None;
    let duration = Duration::span(|| opt_val = Some(f()));
    (opt_val.unwrap(), duration)
}

fn image_open(path: &Path) -> image::ImageResult<DynamicImage> {
    let ref path = ::std::old_path::Path::new(path.to_str().unwrap());
    image::open(path)
}

}
